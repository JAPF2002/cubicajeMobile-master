<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prueba Bodega 3D v3.2 (controles integrados)</title>
  <style>
    :root{ --bg:#0a0f1e; --panel:#121a35; --text:#e8eefc; --muted:#a9b9e3; --accent:#66ccff; --panelH:64px; }
    *{ box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; overflow: hidden; }
    .wrap { height: 100%; display: grid; grid-template-rows: var(--panelH) 1fr; }
    .panel {
      height: var(--panelH);
      display: grid; grid-template-columns: repeat(5, minmax(120px, 1fr)) auto; gap: 8px;
      align-items: center;
      padding: 10px 12px; background: var(--panel); border-bottom: 1px solid #1e2950;
    }
    label { font-size: 12px; color: var(--muted); display: block; margin-bottom: 4px; }
    .field { display: flex; flex-direction: column; justify-content: center; }
    input[type="number"] {
      width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid #2a3a6a;
      background: #0f1630; color: var(--text);
    }
    .chk { display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--muted); justify-content: flex-start; }
    button { padding: 10px 14px; border-radius: 10px; border: 0; background: #1d2a54; color: #fff; font-weight: 700; cursor: pointer; }
    button:hover { filter: brightness(1.1); }
    .info { display:flex; align-items:center; gap:12px; font-size: 13px; color: var(--muted); padding-left: 8px; }
    .scene { position: relative; width: 100%; height: calc(100dvh - var(--panelH)); touch-action: none; }
    canvas.webgl { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }
    .hint { position:absolute; top:10px; left:10px; background: rgba(0,0,0,.4); padding: 6px 8px; border-radius: 8px; font-size: 12px; color: #dbe6ff; z-index: 1; }
    .badge { padding: 2px 6px; border-radius: 6px; background: #13214a; color: #cfe0ff; font-weight: 600; }
    .btns{ display:flex; gap:8px; justify-content:flex-end; }
  </style>

<script>
(function() {
  // Queue messages until RN WebView is ready
  var __RN_READY__ = false;
  var __QUEUE__ = [];
  function flushQueue() {
    while (__QUEUE__.length) {
      try { window.ReactNativeWebView.postMessage(JSON.stringify(__QUEUE__.shift())); } catch (e) { break; }
    }
  }
  // Notify RN that the scene is ready (or after onload)
  function notifyReady() {
    if (__RN_READY__) return;
    __RN_READY__ = true;
    try {
      window.ReactNativeWebView && window.ReactNativeWebView.postMessage(JSON.stringify({type:'READY'}));
      flushQueue();
    } catch(e) {}
  }
  // Public API to receive messages from React Native
  window.receiveFromReactNative = function(payload) {
    try {
      var msg = (typeof payload === 'string') ? JSON.parse(payload) : payload;
      // Supported: SET_DATA, CAMERA_TO, HILITE_BIN
      if (msg && msg.type === 'SET_DATA' && window.updateSceneData) {
        window.updateSceneData(msg.data);
      }
      if (msg && msg.type === 'CAMERA_TO' && window.cameraTo) {
        window.cameraTo(msg.target);
      }
      if (msg && msg.type === 'HILITE_BIN' && window.highlightBin) {
        window.highlightBin(msg.id);
      }
    } catch (e) { console.error('receiveFromReactNative error', e); }
  };
  // Helper to emit events back to RN
  window.emitToRN = function(evt) {
    var payload = (typeof evt === 'string') ? {type:'LOG', message: evt} : evt;
    if (!__RN_READY__) { __QUEUE__.push(payload); return; }
    try {
      window.ReactNativeWebView && window.ReactNativeWebView.postMessage(JSON.stringify(payload));
    } catch (e) { console.error('postMessage failed', e); }
  };
  // Hook clicks in the 3D scene if global handler present
  window.addEventListener('load', function() { notifyReady(); });
  // Example: suppose your app sets these functions elsewhere:
  // - window.updateSceneData(data)
  // - window.cameraTo({x,y,z})
  // - window.highlightBin(id)
  // And internally call: emitToRN({type:'CLICK', id: binId});
})();
</script>

</head>
<body>
<div class="wrap">
  <div class="panel">
    <div class="field">
      <label for="l">Largo (m)</label>
      <input id="l" type="number" inputmode="decimal" step="0.01" min="0" value="10">
    </div>
    <div class="field">
      <label for="a">Ancho (m)</label>
      <input id="a" type="number" inputmode="decimal" step="0.01" min="0" value="6">
    </div>
    <div class="field">
      <label for="h">Alto (m)</label>
      <input id="h" type="number" inputmode="decimal" step="0.01" min="0" value="3">
    </div>
    <div class="chk">
      <input id="openFront" type="checkbox" checked>
      <label for="openFront">Frente abierto</label>
    </div>
    <div class="info">
      <span>Volumen: <span id="vol" class="badge">â€”</span></span>
      <span>Escala: <span class="badge">1 unidad = 1 m</span></span>
    </div>
    <div class="btns">
      <button id="btnCenter">Centrar vista</button>
      <button id="btn">Actualizar</button>
    </div>
  </div>
  <div class="scene" id="scene">
    <div class="hint">ðŸ“Œ Controles: Arrastrar = orbitar Â· Ctrl + arrastrar = desplazar Â· Rueda/Pinch = zoom</div>
  </div>
</div>

<script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
<script>
  const elScene = document.getElementById('scene');
  const elL = document.getElementById('l');
  const elA = document.getElementById('a');
  const elH = document.getElementById('h');
  const elOpen = document.getElementById('openFront');
  const elVol = document.getElementById('vol');
  const elBtn = document.getElementById('btn');
  const elBtnCenter = document.getElementById('btnCenter');

  // Three.js bÃ¡sico
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0f1e);
  const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
  const canvas = renderer.domElement;
  canvas.className = "webgl";
  elScene.appendChild(canvas);
  const DPR = Math.min(window.devicePixelRatio || 1, 2);

  const camera = new THREE.PerspectiveCamera(55, 1, 0.01, 10000);

  // "Controles" caseros: Ã³rbita en esfÃ©ricas + pan + zoom
  const target = new THREE.Vector3(0,1.5,0);
  let radius = 14, theta = Math.PI/4, phi = Math.PI/4; // esfÃ©ricas
  const minRadius = 2, maxRadius = 200;
  function updateCamera(){
    // Limitar phi (0..pi) sin cruzar los polos
    const eps = 0.001;
    phi = Math.min(Math.max(eps, phi), Math.PI - eps);
    radius = Math.min(Math.max(minRadius, radius), maxRadius);
    const x = target.x + radius * Math.sin(phi) * Math.cos(theta);
    const y = target.y + radius * Math.cos(phi);
    const z = target.z + radius * Math.sin(phi) * Math.sin(theta);
    camera.position.set(x,y,z);
    camera.lookAt(target);
  }
  updateCamera();

  // Luces + grilla
  scene.add(new THREE.AmbientLight(0xffffff,0.45));
  const hemi = new THREE.HemisphereLight(0xcfe8ff, 0x18243f, 0.7); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(6, 10, 6); scene.add(dir);
  scene.add(new THREE.AxesHelper(3));
  const grid = new THREE.GridHelper(200, 200, 0x6aa9ff, 0x2b3e72); grid.material.opacity = 0.45; grid.material.transparent = true; scene.add(grid);

  let boxGroup = new THREE.Group(); scene.add(boxGroup);

  function fmt(n){ return (isFinite(n) ? Number(n).toFixed(2) : "0.00"); }

  function setDims(l, a, h, openFront=true){
    scene.remove(boxGroup); boxGroup = new THREE.Group();
    const geom = new THREE.BoxGeometry(l, h, a);
    const wall = new THREE.MeshPhongMaterial({ color: 0x89b4ff, opacity: 0.25, transparent: true, depthWrite:false });
    const invisible = new THREE.MeshPhongMaterial({ visible:false });
    const mesh = new THREE.Mesh(geom, openFront ? [wall, wall, wall, wall, invisible, wall] : wall);
    const edges = new THREE.EdgesGeometry(geom);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff }));
    mesh.position.set(0, h/2, 0); line.position.set(0, h/2, 0);
    boxGroup.add(mesh); boxGroup.add(line); scene.add(boxGroup);

    // Reencuadrar cÃ¡mara a tamaÃ±o
    const maxDim = Math.max(l, a, h);
    radius = Math.max(4, maxDim * 1.1);
    target.set(0, h/2, 0);
    updateCamera();

    elVol.textContent = fmt(l * a * h) + " mÂ³";
  }

  // Resize estable
  let lastW=0,lastH=0,rafId=0;
  function doSize(){
    const r=elScene.getBoundingClientRect();
    const w=Math.round(r.width), h=Math.round(r.height);
    if(w===lastW && h===lastH) return;
    lastW=w; lastH=h;
    renderer.setPixelRatio(DPR);
    renderer.setSize(w,h,false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  function onResize(){ cancelAnimationFrame(rafId); rafId = requestAnimationFrame(doSize); }
  window.addEventListener("resize", onResize);
  doSize();

  // Inputs
  function updateFromInputs(){
    const l = Math.max(0.01, parseFloat((elL.value||"0").replace(",", ".")) || 0.01);
    const a = Math.max(0.01, parseFloat((elA.value||"0").replace(",", ".")) || 0.01);
    const h = Math.max(0.01, parseFloat((elH.value||"0").replace(",", ".")) || 0.01);
    const of = !!elOpen.checked;
    setDims(l, a, h, of);
  }
  elBtn.addEventListener("click", updateFromInputs);
  elBtnCenter.addEventListener("click", () => { updateCamera(); });
  elOpen.addEventListener("change", updateFromInputs);

  // Controles con mouse/touch (sin librerÃ­as)
  let isDragging = false;
  let lastX = 0, lastY = 0;
  let lastDist = 0; // para pinch zoom

  function onPointerDown(e){
    isDragging = true;
    lastX = e.clientX; lastY = e.clientY;
  }
  function onPointerMove(e){
    if(!isDragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    if (e.ctrlKey || e.button === 1 || e.button === 2) {
      // PAN (Ctrl + arrastrar o botÃ³n medio/derecho): movemos el target en el plano de la cÃ¡mara
      const panSpeed = 0.005 * radius;
      const panX = -dx * panSpeed;
      const panY =  dy * panSpeed;
      // AproximaciÃ³n simple: pan en ejes de pantalla
      target.x += panX;
      target.y += panY;
    } else {
      // ORBIT
      theta -= dx * 0.005;
      phi   -= dy * 0.005;
    }
    lastX = e.clientX; lastY = e.clientY;
    updateCamera();
  }
  function onPointerUp(){ isDragging = false; }
  function onWheel(e){
    e.preventDefault();
    const zoomFactor = 1 + Math.abs(e.deltaY) * 0.0015;
    if (e.deltaY > 0) radius *= zoomFactor; else radius /= zoomFactor;
    updateCamera();
  }

  // Touch (pinch / rotate)
  let touchId = null;
  elScene.addEventListener('pointerdown', (e)=>{ elScene.setPointerCapture(e.pointerId); onPointerDown(e); });
  elScene.addEventListener('pointermove', onPointerMove);
  elScene.addEventListener('pointerup', onPointerUp);
  elScene.addEventListener('pointercancel', onPointerUp);
  elScene.addEventListener('wheel', onWheel, { passive: false });

  // Pinch con 2 dedos
  elScene.addEventListener('touchstart', (e)=>{
    if(e.touches.length===2){
      lastDist = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
    }
  }, {passive:true});
  elScene.addEventListener('touchmove', (e)=>{
    if(e.touches.length===2){
      const dist = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
      const delta = dist - lastDist;
      radius *= (1 - delta * 0.003);
      lastDist = dist;
      updateCamera();
    }
  }, {passive:true});

  // Render loop
  (function loop(){ renderer.render(scene, camera); requestAnimationFrame(loop); })();

  // Inicial
  setDims(10, 6, 3, true);
  onResize();
</script>
</body>
</html>
